我对该操作系统的改进：
	1、改用分页机制实现虚拟内存		之前是采用分段机制,灵活性很差						2013-12-15 11:14 耗时3天。这个耗时比较长,主要是“修改”比重写麻烦,修改一个地方,可能导致其他很多地方出问题
	2、增加文件缓存			在内存1MB - 6MB之间建立文件缓存区,减少读盘次数,加快文件操作速度		2013-12-16 11:52 耗时1天
	3、增加写时复制			fork的时候只需要建立页目录、页表,而不用复制代码、数据、堆栈			2013-12-17 11:59 耗时1天
	4、exec建立新程序时,文件按需读取	exec只读取程序文件的最后一页到内存(传递参数),其他的在程序运行时按需读取	2013-12-18 23:08 耗时1.5天。这个耗时也比较长,主要是修改了IPC机制,修改总是会造成新的问题,大部分时间都在调试修改后的IPC
	
改进后的操作系统性能评价：
	1、分页机制的引入,改变了之前分段机制的内存分配模式。之前是设计的时候就划定内存,程序运行的时候只能在指定地址、指定大小的范围内。现在以4KB一页为单位进行内存分配,要多少才动态分配多少,极大减少了浪费。最直观的感觉就是：之前32MB的内存,每个子进程分配1MB,最多只能同时开启20个子进程(10MB以下被系统用于其他目的),现在开100个子进程都没问题(默认最多64个,不过这个直接可以改,没有后遗症)。
	2、文件缓存极大减少了读盘次数。bochs下面的读盘指示灯只会在文件第一次被读取的时候闪一下,之后的读取全是内存中的文件缓存里进行。(不过感觉不到速度的变化,估计磁盘是虚拟的,访问速度没有实际的慢)。
	3、写时复制。在fork的时候,只建立子进程页表,不再复制数据,极大提高了子进程建立速度。现在fork基本感觉不到停顿。
	4、exec的文件按需分配是改进后的最大亮点。以前建立新程序,每次都要读盘、复制文件,耗时大概2秒。现在只建立页目录,程序运行的时候才实时按需读取文件。新程序启动时间明显缩短。shell里启动命令,基本感觉不到停顿。
	
不足：
	1、文件缓存主要涉及了“申请”,对“释放”未作过多设计。(主要是现在文件不多,所有文件加起来的大小还没内存缓存大,所以就懒得去搞了)
	2、内存管理未涉及页换入换出。(原因和1差不多,也是现在内存看起来还比较充足,暂时不需要考虑换入换出)
	3、程序exit之后未释放内存。(来不及考虑那么多了,先走起来,以后有精力再完善)
----------------------------------------------------------------------------------------------------

该操作系统基本完工了！浩大的工程啊！
覃攀	QQ:407802625	2013-12-18 23:10
----------------------------------------------------------------------------------------------------
又一次修改：
	1、将子进程的虚拟内存大小从之前的2MB改成了系统最大内存(其实也可以改成4GB,但是那要增加页表大小)
	2、GDT总数改成了(8192 - 1),目的是支持更多的子进程
	3、系统同时打开文件总数改成了1024,目的也是为了支持更多子进程
	4、子进程总数改成了256(再多就会使内核不能容身于1MB内存之内了)
覃攀	QQ:407802625	2013-12-19 13:05
----------------------------------------------------------------------------------------------------
再一次修改：
	1、将GDT总数改成了6：
		空
		内核数据段
		内核代码段
		用户数据段
		用户代码段
		TSS段
	附：这是向linux学的,简化了分段机制,减少了对硬件的依赖,从而增强了操作系统的可移植性(真不知道我是怎么想到8192个GDT的。。。)
	2、系统任务、进程以及子进程的特权级都改成了3,现在整个系统就两个特权级0、3。这也是向linux学的,该简化的就简化
	3、去掉了专为VGA输出而设置的视频段,改为使用数据段。(在之前的地址上加个VGA_MEM_BASE就可以了)
覃攀	QQ:407802625	2013-12-20 11:21
----------------------------------------------------------------------------------------------------
继续修改：
	1、建立了任务控制块的双向链表
	2、进程调度、TCB申请、TCB释放等操作都采用双向链表。当系统总进程数较大时,这种方法效率较高
	附：之前的TCB操作都是在task_table中从头搜到尾,比较费时。以前进程数少的时候,感觉不到效率低下,但是当我把系统子进程总数改成256之后,速度明显降了下来。
	之前的方法,task_idle的计数增量(增量越大,表示系统占用资源越少)是530万左右,改进之后,达到了643万。效果还是相当明显的。
覃攀	QQ:407802625	2013-12-20 13:37
----------------------------------------------------------------------------------------------------
又一次改进：
	1、增加了内存释放。在子进程退出时,可以释放内存
	但是效果不好:
		1、系统不稳定,连续fork几百次就会重启,目前还没弄清原因
		2、还不能释放页目录、页表占用的内存。这个问题也还没想好怎么解决
		3、shell占用内存的问题。shell调用fork后,父进程对堆栈的操作会导致写时复制。每fork一次,就写时复制一次,而子程序退出后,shell不知道该怎么释放相应内存。多次累积后,“内存使用情况记录”越来越大,可能溢出到堆栈区,引起系统崩溃
		4、第3个问题,可能是第1个问题的原因。
	最后在 mm.h 中增加了一个宏 _FREE_MEM_ ,如果定义了这个宏,就会产生释放内存的代码,否则不会产生。
	
覃攀	QQ:407802625	2013-12-20 21:20
----------------------------------------------------------------------------------------------------
再改：
	1、将va2pa va2pte从c语言改成汇编实现
	2、将memcopy直接改成汇编宏定义
	目    的：提升系统的效率。
	实际效果：之前的task_idle计数增量是643万,改进后提升到了646万。
	附：对效率提升最明显的是memcopy。
覃攀	QQ:407802625	2013-12-23 12:54